<!DOCTYPE html>
<html>

<head>


    <meta charset="UTF-8">


    <title>15.5 String オブジェクト (String Objects)</title>


    <link rel="stylesheet" title="Metagraphix Graytone" type="text/css" href="css/ecma.css" media="all"/>
    <link rel="stylesheet" title="Metagraphix NN4" type="text/javascript" href="js/n4.js" media="screen"/>

    <link rel="bookmark" title="Translator"
          href="mailto:TAKI%20%3Coz-07ams&#64;mvh.biglobe.ne.jp%3E"/>
    <link rel="bookmark" title="Site Top"
          href="http://www2u.biglobe.ne.jp/%7Eoz-07ams/"/>
    <link rel="start begin toc" title="ECMA-262 revision 3"
          href="index.html"/>
    <link rel="prev" title="15-4_Array_Objects"
          href="15-4_Array_Objects.html"/>
    <link rel="next" title="15-6_Boolean_Objects"
          href="15-6_Boolean_Objects.html"/>

    <link rev="alternate" title="Original Document (PDF format)"
          type="application/pdf" hreflang="en"
          href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf"/>


</head>

<body>


<p>
    <a href="#toc">本頁の目次</a>
    <a rel="contents" href="">目次</a>
    <a rel="next" href="15-6_Boolean_Objects.html">次頁: 15-6_Boolean_Objects</a>
    <a rel="prev" href="15-4_Array_Objects.html">前頁: 15-4_Array_Objects</a>
</p>


<div class="section level1">
    <h1 id="section-15.5">15.5 String オブジェクト (String Objects)</h1>


    <div class="section level2">
        <h2 id="section-15.5.1">15.5.1 関数として呼出される String コンストラクタ (The String Constructor Called as a Function)</h2>


        <div class="body level2">
            <p>String がコンストラクタとしてではなく関数として呼出されると、型変換を行う。</p>
        </div>
        <!-- END of 15.5.1 Body -->


        <div class="section level3">
            <h3 id="section-15.5.1.1">15.5.1.1 String ( [ value ] )</h3>


            <div class="body level3">
                <p>ToString(<var>value</var>) で算出される (String オブジェクトではなく) 文字列値 を返す。 <var>value</var> が供給されないならば、空文字列
                    &quot;&quot; が返される。</p>
            </div>
            <!-- END of 15.5.1.1 Body -->

        </div>
        <!-- END of 15.5.1.1 -->

    </div>
    <!-- END of 15.5.1 -->


    <div class="section level2">
        <h2 id="section-15.5.2">15.5.2 String コンストラクタ (The String Constructor)</h2>


        <div class="body level2">
            <p><code class="keyword">new</code> 式の一部として呼出される String は、コンストラクタである: 新規にオブジェクトを生成し、初期化する。</p>
        </div>
        <!-- END of 15.5.2 Body -->


        <div class="section level3">
            <h3 id="section-15.5.2.1">15.5.2.1 new String ( [ value ] )</h3>


            <div class="body level3">
                <p>新規に構築されたオブジェクトの [[Prototype]] プロパティは、 String.prototype (<a
                        href="15-5_String_Objects.html#section-15.5.3.1">セクション 15.5.3.1</a>) の初期値である、オリジナルの String
                    プロトタイプオブジェクトに設定される。</p>

                <p>新規に構築されたオブジェクトの [[Class]] プロパティは、 &quot;String&quot; に設定される。</p>

                <p>新規に構築されたオブジェクトの [[Value]] プロパティは、 ToString(<var>value</var>) に設定され、 <var>value</var>
                    が供給されないければ空文字列に設定される。</p>
            </div>
            <!-- END of 15.5.2.1 Body -->

        </div>
        <!-- END of 15.5.2.1 -->

    </div>
    <!-- END of 15.5.2 -->


    <div class="section level2">
        <h2 id="section-15.5.3">15.5.3 String コンストラクタ のプロパティ (Properties of the String Constructor)</h2>


        <div class="body level2">
            <p>String コンストラクタの内部 [[Prototype]] プロパティの値は、 Function プロトタイプオブジェクト (<a
                    href="15-3_Function_Objects.html#section-15.3.4">セクション 15.3.4</a>) である。</p>

            <p>内部プロパティと length プロパティ (値は 1) の他に、 String コンストラクタは次のプロパティを持つ:</p>
        </div>
        <!-- END of 15.5.3 Body -->


        <div class="section level3">
            <h3 id="section-15.5.3.1">15.5.3.1 String.prototype</h3>


            <div class="body level3">
                <p>String.prototype の初期値は String プロトタイプオブジェクト (<a href="15-5_String_Objects.html#section-15.5.4">セクション
                    15.5.4</a>) である。</p>

                <p>このプロパティは属性 { DontEnum, DontDelete, ReadOnly } を持つ。</p>
            </div>
            <!-- END of 15.5.3.1 Body -->

        </div>
        <!-- END of 15.5.3.1 -->


        <div class="section level3">
            <h3 id="section-15.5.3.2">15.5.3.2 String.fromCharCode ( [ char0 [ , char1 [ , ... ] ] ] )</h3>


            <div class="body level3">
                <p>引数の数と同数で構成される文字列値を返す。各引数は、左から右へ、第 1 引数が第 1 文字目を指定、というように、結果文字列の 1 文字を指定する。引数は、演算 ToUint16 (<a
                        href="9_Type_Conversion.html#section-9.7">セクション 9.7</a>) の適用し、結果の 16
                    ビット整数を文字のコードポイント値とみなし、文字に変換される。 引数が供給されないならば、結果は空文字列である。</p>

                <p><code>fromCharCode</code> 関数の length プロパティは 1 である。</p>
            </div>
            <!-- END of 15.5.3.2 Body -->

        </div>
        <!-- END of 15.5.3.2 -->

    </div>
    <!-- END of 15.5.3 -->


    <div class="section level2">
        <h2 id="section-15.5.4">15.5.4 String プロトタイプオブジェクトのプロパティ (Properties of the String Prototype Object)</h2>


        <div class="body level2">
            <p>String プロトタイプオブジェクトは、値が空文字列である String オブジェクト ([[Class]] が &quot;String&quot;) それ自身である。</p>

            <p>String プロトタイプオブジェクトの内部 [[Prototype]] プロパティの値は、 Object プロトタイプオブジェクト (<a
                    href="15-2_Object_Objects.html#section-15.2.3.1">セクション 15.2.3.1</a>) である。</p>
        </div>
        <!-- END of 15.5.4 Body -->


        <div class="section level3">
            <h3 id="section-15.5.4.1">15.5.4.1 String.prototype.constructor</h3>


            <div class="body level3">
                <p>String.prototype.constructor の初期値は String コンストラクタである。</p>
            </div>
            <!-- END of 15.5.4.1 Body -->

        </div>
        <!-- END of 15.5.4.1 -->


        <div class="section level3">
            <h3 id="section-15.5.4.2">15.5.4.2 String.prototype.toString ( )</h3>


            <div class="body level3">
                <p>この文字列値を返す。 (String オブジェクトでは、 <code>toString</code> メソッドは valueOf メソッドと同じものを返すということが起こることに注意。)</p>

                <p><code>toString</code> 関数は汎用的ではない; <code class="keyword">this</code> 値が String オブジェクトでなければ、例外
                    TypeError を投げる。それゆえ、他の種類のオブジェクトにメソッドとして転用できない。</p>
            </div>
            <!-- END of 15.5.4.2 Body -->

        </div>
        <!-- END of 15.5.4.2 -->


        <div class="section level3">
            <h3 id="section-15.5.4.3">15.5.4.3 String.prototype.valueOf ( )</h3>


            <div class="body level3">
                <p>この文字列値を返す。</p>

                <p><code>valueOf</code> 関数は汎用的ではない; <code class="keyword">this</code> 値が String オブジェクトでなければ、例外 TypeError
                    を投げる。それゆえ、他の種類のオブジェクトにメソッドとして転用できない。</p>
            </div>
            <!-- END of 15.5.4.3 Body -->

        </div>
        <!-- END of 15.5.4.3 -->


        <div class="section level3">
            <h3 id="section-15.5.4.4">15.5.4.4 String.prototype.charAt (pos)</h3>


            <div class="body level3">
                <p>このオブジェクトから文字列に変換された結果文字列内の位置 <var>pos</var> の文字で構成される文字列を返す。その位置に文字がないならば、結果は空文字列である。結果は文字列値であり、
                    String オブジェクトではない。</p>

                <p><var>pos</var> が整数である Number 型の値ならば、 <var>x</var>.<code>charAt</code>(<var>pos</var>) の結果は
                    <var>x</var>.substring(<var>pos</var>, <var>pos</var>+1) の結果と等しい。</p>

                <p><code>charAt</code> メソッドが 1 個の引数 <var>pos</var> で呼ばれると、 次のステップが取られる:</p>
                <ol>
                    <li>ToString を呼出し、引数に <code class="keyword">this</code> 値を与える。</li>
                    <li>ToInteger(<var>pos</var>) を呼出す。</li>
                    <li>Result(1) の文字数を算出する。</li>
                    <li>Result(2) が 0 未満、または Result(3) 以上ならば、空文字列を返す。</li>
                    <li>Result(1) からの 1 文字、 すなわち Result(1) の第 1 (最左) 文字を位置 0, 次を位置 1, と考え、位置 Result(2) の文字で構成される、長さ 1
                        の文字列を返す。
                    </li>
                </ol>
                <div class="note">
                    <p><b>NOTE</b> <code>charAt</code> 関数は故意に汎用的である; <code class="keyword">this</code> 値が String
                        オブジェクトであることを要求されない。それゆえ、他の種類のオブジェクトにメソッドとして転用可能である。</p>
                </div>

            </div>
            <!-- END of 15.5.4.4 Body -->

        </div>
        <!-- END of 15.5.4.4 -->


        <div class="section level3">
            <h3 id="section-15.5.4.5">15.5.4.5 String.prototype.charCodeAt (pos)</h3>


            <div class="body level3">
                <p>このオブジェクトを文字列へ変換した結果文字列の位置 <var>pos</var> の文字のコードポイント値をあらわす数 (0 以上 216 未満の整数) を返す。その位置に文字が存在しないならば、結果は
                    NaN である。</p>

                <p><code>charCodeAt</code> メソッドが 1 個の引数 <var>pos</var> で呼出されるとき、次のステップが取られる:</p>
                <ol>
                    <li>ToString を呼出し、引数に <code class="keyword">this</code> 値を与える。</li>
                    <li>ToInteger(<var>pos</var>) を呼出す。</li>
                    <li>Result(1) の文字をを算出する。</li>
                    <li>Result(2) が 0 未満、または Result(3) 以上ならば、 NaN を返す。</li>
                    <li>Result(1) の最初の (最左) 文字を位置 0、 次を位置 1 として、文字列 Result(1) の位置 Result(2) の文字のコードポイント値である Number
                        型の値を返す。
                    </li>
                </ol>
                <div class="note">
                    <p><b>NOTE</b> <code>charCodeAt</code> 関数は故意に汎用的である; <code class="keyword">this</code> 値が String
                        オブジェクトであることを要求されない。それゆえ、他の種類のオブジェクトにメソッドとして転用可能である。</p>
                </div>

            </div>
            <!-- END of 15.5.4.5 Body -->

        </div>
        <!-- END of 15.5.4.5 -->


        <div class="section level3">
            <h3 id="section-15.5.4.6">15.5.4.6 String.prototype.concat ( [ string1 [ , string2 [ , ... ] ] ] )</h3>


            <div class="body level3">
                <p><code>concat</code> メソッドが 0 個以上の引数 <var>string1</var>, <var>string2</var>, etc. で呼出されると、
                    <var>string1</var>, <var>string2</var>, etc. のそれぞれ (各引数は文字列に変換される) の文字が続く (文字列に変換された)
                    このオブジェクトの文字で構成される文字列を返す。 結果は文字列値であり、 String オブジェクトではない。 次のステップが取られる:</p>
                <ol>
                    <li>ToString を呼出し、引数に <code class="keyword">this</code> 値を与える。</li>
                    <li><var>R</var> を Result(1) とする。</li>
                    <li>引数リストから次の引数を取得する; これ以上引数がないならば、 ステップ 7 へ。</li>
                    <li>ToString(Result(3)) を呼出す。</li>
                    <li><var>R</var> を 文字 Result(4) の続く、前の <var>R</var> の値内の文字で構成される文字列値とする。</li>
                    <li>ステップ 3 へ。</li>
                    <li><var>R</var> を返す。</li>
                </ol>
                <p><code>concat</code> メソッドの length プロパティは 1 である。</p>

                <div class="note">
                    <p><b>NOTE</b> <code>concat</code> 関数は故意に汎用的である; <code class="keyword">this</code> 値が String
                        オブジェクトであることを要求されない。それゆえ、他の種類のオブジェクトにメソッドとして転用可能である。</p>
                </div>

            </div>
            <!-- END of 15.5.4.6 Body -->

        </div>
        <!-- END of 15.5.4.6 -->


        <div class="section level3">
            <h3 id="section-15.5.4.7">15.5.4.7 String.prototype.indexOf (searchString, position)</h3>


            <div class="body level3">
                <p><var>searchString</var> が、このオブジェクトの文字列への変換結果の部分文字列として <var>position</var> と同じかそれ以上の 1
                    個以上の位置で出現するならば、その <var>position</var> の最小のインデックスが返される; そうでなければ、 -1 が返される。 <var>position</var> が
                    undefined ならば、 0 が想定され、文字列全域を検索する。</p>

                <p><code>indexOf</code> メソッドは 2 個の引数 <var>searchString</var> と <var>position</var> をとり、次のステップを実行する:</p>
                <ol>
                    <li>ToString を呼出し、引数に <code class="keyword">this</code> 値を与える。</li>
                    <li>ToString(<var>searchString</var>) を呼出す。</li>
                    <li>ToInteger(<var>position</var>) を呼出す。 (<var>position</var> が undefined ならば、このステップは値 0 を生成する)。
                    </li>
                    <li>Result(1) の文字数を算出する。</li>
                    <li>min(max(Result(3), <a href="Brief_History.html#section-0">0</a>), Result(4)) を算出する。</li>
                    <li>Result(2) である文字列の文字数を算出する。</li>
                    <li><var>k</var>+Result(6) が Result(4) より大きくなく、かつ Result(6) より小さい全ての負でない整数 <var>j</var> に対して
                        Result(1) の位置 <var>k</var>+j の文字が Result(2) の位置 <var>j</var> の文字と同じであるような Result(5)
                        より小さくない最小の可能な整数 <var>k</var> を算出する; そのような整数 <var>k</var> が存在しないならば、値 -1 を算出する。
                    </li>
                    <li>Result(7) を返す。</li>
                </ol>
                <p><code>indexOf</code> メソッドの length プロパティは 1 である。</p>

                <div class="note">
                    <p><b>NOTE</b> <code>indexOf</code> 関数は故意に汎用的である; <code class="keyword">this</code> 値が String
                        オブジェクトであることを要求されない。それゆえ、他の種類のオブジェクトにメソッドとして転用可能である。</p>
                </div>

            </div>
            <!-- END of 15.5.4.7 Body -->

        </div>
        <!-- END of 15.5.4.7 -->


        <div class="section level3">
            <h3 id="section-15.5.4.8">15.5.4.8 String.prototype.lastIndexOf (searchString, position)</h3>


            <div class="body level3">
                <p><var>searchString</var> が、このオブジェクトの文字列への変換結果の部分文字列として <var>position</var> と同じかそれ以上の 1
                    個以上の位置で出現するならば、その <var>position</var> の最大のインデックスが返される; そうでなければ、 -1 が返される。 <var>position</var> が
                    undefined ならば、文字列値の長さが想定され、文字列全域を検索する。</p>

                <p><code>lastIndexOf</code> メソッドは 2 個の引数 <var>searchString</var> と <var>position</var> をとり、次のステップを実行する:
                </p>
                <ol>
                    <li>ToString を呼出し、引数に <code class="keyword">this</code> 値を与える。</li>
                    <li>ToString(<var>searchString</var>) を呼出す。</li>
                    <li>ToNumber(<var>position</var>) を呼出す。 (<var>position</var> が undefined ならば、このステップは値 NaN を生成する)。
                    </li>
                    <li>Result(3) が NaN ならば、 +∞ を用いる; そうでなければ、 ToInteger(Result(3)) を呼出す。</li>
                    <li>Result(1) の文字数を算出する。</li>
                    <li>min(max(Result(4), <a href="Brief_History.html#section-0">0</a>), Result(5)) を算出する。</li>
                    <li>Result(2) である文字列の文字数を算出する。</li>
                    <li><var>k</var>+Result(7) が Result(5) より大きくなく、かつ Result(7) より小さい全ての負でない整数 <var>j</var> に対して
                        Result(1) の位置 <var>k</var>+j の文字がResult(2) の位置 <var>j</var> の文字と同じであるような、 Result(6)
                        より大きくない最大の負でない整数 <var>k</var> を算出する; そのような整数 <var>k</var> が存在しないならば、値 -1 を算出する。
                    </li>
                    <li>Result(8) を返す。</li>
                </ol>
                <p><code>lastIndexOf</code> メソッドの length プロパティは 1 である。</p>

                <div class="note">
                    <p><b>NOTE</b> <code>lastIndexOf</code> 関数は故意に汎用的である; <code class="keyword">this</code> 値が String
                        オブジェクトであることを要求されない。それゆえ、他の種類のオブジェクトにメソッドとして転用可能である。</p>
                </div>

            </div>
            <!-- END of 15.5.4.8 Body -->

        </div>
        <!-- END of 15.5.4.8 -->


        <div class="section level3">
            <h3 id="section-15.5.4.9">15.5.4.9 String.prototype.localeCompare (that)</h3>


            <div class="body level3">
                <p><code>localeCompare</code> メソッドが 1 個の引数 <var>that</var> で呼出されるとき、このオブジェクト (文字列に変換される) と
                    <var>that</var> (文字列に変換される) のロケールに反応する文字列比較の結果を表す NaN 以外の数を返す。 2
                    個の文字列が実装が定義する方法で比較される。結果は、システムのデフォルトのロケールが規定する並び順に文字列を並べることを意図され、this が <var>that</var>
                    よりも前に来るか、同じか、後にくるかによって、それぞれ負、0、正になる。</p>

                <p><code>localeCompare</code> メソッドを 2 個の引数 <code class="keyword">this</code> と <var>that</var>
                    をとると関数と考えるならば、全文字列セットにおける矛盾のない比較関数 (<a href="15-4_Array_Objects.html#section-15.4.4.11">セクション
                        15.4.4.11</a> で定義される) である。さらに、 Unicode 標準によって規準的に等価 (canonically equivalent) と考えられる 2
                    個の文字列を比較するとき、 <code>localeCompare</code> は 0 または -0 を返す。</p>

                <p>実際の戻り値は、結果の値の追加情報の符号化を実装者に許可することを実装定義に残されるが、この関数は文字列の全てを全体的な並びを定義することを要求され、 Unicode 標準によって規準的に等価
                    (canonically equivalent) と考えられる 2 個の文字列を比較するとき、 0 を返す。</p>

                <div class="note">
                    <p><b>NOTE</b> <code>localeCompare</code> メソッド自身を直接 Array.prototype.sort の引数にするのは、後者は 2
                        個の引数を要求するので適切ではない。</p>
                </div>

                <div class="note">
                    <p><b>NOTE</b> この関数は、ホスト環境から ECMAScript
                        環境に対して言語に反応する比較機能が可能になっていることを当てにして、ホスト環境の現在のロケールの規則に従った比較を意図される。この関数が Unicode 標準に従って規準的に等価
                        (canonically equivalent) である文字列を同一として扱うことが強く推奨される (言い換えると、双方の文字列をまず標準化形式 <var>C</var> または
                        <var>D</var> に変換したかのように比較する)。この関数はまた Unicode 互換の等価性また分解を信頼しないことを推奨される。</p>
                </div>

                <p>全く言語に反応しない比較がホスト環境から可能ならば、この関数はビット比較を行ってよい。</p>

                <div class="note">
                    <p><b>NOTE</b> <code>localeCompare</code> 関数は故意に汎用的である; <code class="keyword">this</code> 値が String
                        オブジェクトであることを要求されない。それゆえ、他の種類のオブジェクトにメソッドとして転用可能である。</p>
                </div>

                <div class="note">
                    <p><b>NOTE</b> この関数の第二パラメータは、この標準の将来のバージョンで使用される可能性がある; 実装はこのパラメータを他の用途に使用しないことを推奨する。</p>
                </div>

            </div>
            <!-- END of 15.5.4.9 Body -->

        </div>
        <!-- END of 15.5.4.9 -->


        <div class="section level3">
            <h3 id="section-15.5.4.10">15.5.4.10 String.prototype.match (regexp)</h3>


            <div class="body level3">
                <p><var>regexp</var> がその [[Class]] プロパティが &quot;RegExp&quot; であるオブジェクトでないならば、それは式 <code class="keyword">new</code>
                    RegExp(<var>regexp</var>) の結果に置換される。 string を <code class="keyword">this</code>
                    値の文字列への変換結果とする。次の一つを行う:</p>
                <ul>
                    <li><var>regexp</var>.global が false ならば: <var>regexp</var> の prototype.exec.RegExp (<a
                            href="15-10_RegExp_Objects.html#section-15.10.6.2">セクション 15.10.6.2</a> 参照) 呼出して、パラメータとして
                        string を渡し、取得される結果を返す。
                    </li>
                    <li><var>regexp</var>.global が true ならば: <var>regexp</var>.lastIndex プロパティを 0 に設定し、マッチするまで
                        RegExp.prototype.exec を繰返し呼出す。空文字列でマッチする (つまり <var>regexp</var>.lastIndex の値が無変更のまま) ならば、 <var>regexp</var>.lastIndex
                        を 1 増分する。 <var>n</var> をマッチした数とする。返される値は、 length プロパティを <var>n</var> に設定され、プロパティ 0 から
                        <var>n</var>-1 までがマッチする RegExp.prototype.exec 呼出しの全ての結果の最初の要素に該当する配列である。
                    </li>
                </ul>
                <div class="note">
                    <p><b>NOTE</b> <code>match</code> 関数は故意に汎用的である; <code class="keyword">this</code> 値が String
                        オブジェクトであることを要求されない。それゆえ、他の種類のオブジェクトにメソッドとして転用可能である。</p>
                </div>

            </div>
            <!-- END of 15.5.4.10 Body -->

        </div>
        <!-- END of 15.5.4.10 -->


        <div class="section level3">
            <h3 id="section-15.5.4.11">15.5.4.11 String.prototype.replace (searchValue, replaceValue)</h3>


            <div class="body level3">
                <p><code class="keyword">this</code> 値を文字列に変換した結果を string とする。</p>

                <p><var>searchValue</var> が正規表現 ([[Class]] プロパティが &quot;RegExp&quot; であるオブジェクト) ならば、以下をおこなう: <var>searchValue</var>.global
                    が false ならば、正規表現 <var>searchValue</var> のマッチの最初に関して string を検索する。 <var>searchValue</var>.global が
                    true ならば、正規表現 <var>searchValue</var> のマッチの全てに関して string を検索する。 検索は <var>searchValue</var>.lastIndex
                    の更新を含め String.prototype.match と同様の方法で行う。 <var>m</var> を <var>searchValue</var>
                    内の残りの捕捉括弧の数とする(NCapturingParens が<a href="15-10_RegExp_Objects.html#section-15.10.2.1">セクション
                        15.10.2.1</a> で定義される)。</p>

                <p><var>searchValue</var> が正規表現でないならば、 searchString を ToString(<var>searchValue</var>) として、 searchString
                    の最初の発生に関して string を検索する。 <var>m</var> を 0 とする。</p>

                <p><var>replaceValue</var> が関数ならば、マッチした各部分文字列ごとにその関数を呼出し、次の <var>m</var> + 3 個の引数を渡す。引数 1
                    はマッチした部分文字列である。 <var>searchValue</var> が正規表現ならば、続く <var>m</var> 個の引数は MatchResult (<a
                            href="15-10_RegExp_Objects.html#section-15.10.2.1">セクション 15.10.2.1</a> 参照) 内の捕捉全てである。 引数
                    <var>m</var> + 2 は string 内部でマッチが発生した場所のオフセット、引数 <var>m</var> + 3 は string
                    である。結果は、マッチした部分文字列のそれぞれ該当する関数呼出しの戻り値を必要に応じて文字列に変換して、オリジナルの入力を置換して派生する文字列値となる。</p>

                <p>そうでなければ、 newstring を <var>replaceValue</var> を文字列に変換した結果とする。結果は、マッチした部分文字列のそれぞれを、次の表に規定される置換テキストで
                    newstring 内の文字を置換した newstring から派生する文字列によってオリジナルの入力を置換して派生する文字列値となる。これら $
                    置換は左から右へと行われ、そして、一旦そのような置換が行われれば、新しい置換テキストは更なる置換の主体にはならない。たとえば、
                    &quot;$1,$2&quot;.<code>replace</code>(/(\$(\d))/g, &quot;$$1-$1$2&quot;) は &quot;$1-$11,$1-$22&quot;
                    を返す。 newstring 内で 下のどの形式にもマッチしない $ は、そのまま残される。</p>
                <table>
                    <thead>
                    <tr>
                        <td>Characters</td>
                        <td>Replacement text</td>
                    </tr>
                    </thead>
                    <tr>
                        <td>$$</td>
                        <td>$</td>
                    </tr>
                    <tr>
                        <td>$&amp;</td>
                        <td>マッチした部分文字列</td>
                    </tr>
                    <tr>
                        <td>$`</td>
                        <td>マッチした部分文字列に先行する文字列の部分。</td>
                    </tr>
                    <tr>
                        <td>$'</td>
                        <td>マッチした部分文字列に後続する文字列の部分。</td>
                    </tr>
                    <tr>
                        <td>$n</td>
                        <td><var>n</var> を 1 桁の数字 1-9 、かつ $n に10進数が続かないものとして、 <var>n</var> 番目の捕捉。 <var>n</var>&le;m かつ
                            <var>n</var> 番目の捕捉が undefined ならば、代わりに空文字列を使用する。 <var>n</var>&gt;m ならば、 結果は実装定義である。
                        </td>
                    </tr>
                    <tr>
                        <td>$nn</td>
                        <td>nn を 2 桁の数字 01-99 として、 nn 番目の捕捉。 nn&le;m かつ nn 番目の補足が undefined ならば、代わりに空文字列を使用する。 nn&gt;m
                            ならば、 結果は実装定義である。
                        </td>
                    </tr>
                </table>
                <div class="note">
                    <p><b>NOTE</b> <code>replace</code> 関数は故意に汎用的である; <code class="keyword">this</code> 値が String
                        オブジェクトであることを要求されない。それゆえ、他の種類のオブジェクトにメソッドとして転用可能である。</p>
                </div>

            </div>
            <!-- END of 15.5.4.11 Body -->

        </div>
        <!-- END of 15.5.4.11 -->


        <div class="section level3">
            <h3 id="section-15.5.4.12">15.5.4.12 String.prototype.search (regexp)</h3>


            <div class="body level3">
                <p><var>regexp</var> がその [[Class]] プロパティが &quot;RegExp&quot; であるオブジェクトでないならば、それは式 <code class="keyword">new</code>
                    RegExp(<var>regexp</var>) の結果に置換される。 string を <code class="keyword">this</code> 値の文字列への変換結果とする。</p>

                <p>値 string は、正規表現パターン <var>regexp</var> の発生に対してその開始から検索される。結果はパターンマッチを行う string
                    内部のオフセットを示す数値となり、またマッチしないならば -1 となる。</p>

                <div class="note">
                    <p><b>NOTE</b> このメソッドは <var>regexp</var> の lastIndex プロパティと global プロパティを無視する。 <var>regexp</var> の
                        lastIndex プロパティはそのまま変更されない。</p>
                </div>

                <div class="note">
                    <p><b>NOTE</b> <code>search</code> 関数は故意に汎用的である; <code class="keyword">this</code> 値が String
                        オブジェクトであることを要求されない。それゆえ、他の種類のオブジェクトにメソッドとして転用可能である。</p>
                </div>

            </div>
            <!-- END of 15.5.4.12 Body -->

        </div>
        <!-- END of 15.5.4.12 -->


        <div class="section level3">
            <h3 id="section-15.5.4.13">15.5.4.13 String.prototype.slice (start, end)</h3>


            <div class="body level3">
                <p><code>slice</code> メソッドは 2 個の引数 <var>start</var> と <var>end</var> をとり、このオブジェクトの文字列への変換結果の、位置 <var>start</var>
                    の文字から開始して位置 <var>end</var> の前の文字までを含む部分文字列を返す (または文字列の末尾までなら <var>end</var> は undefined である)。 <var>start</var>
                    が 負 ならば、 sourceLength を文字列の長さとして (sourceLength+<var>start</var>) として扱われる。 <var>end</var> が 負 ならば、
                    sourceLength を文字列の長さとして (sourceLength+<var>end</var>) として扱われる。結果は文字列値となり、 String
                    オブジェクトにはならない。次のステップが取られる:</p>
                <ol>
                    <li>ToString を呼出し、引数に <code class="keyword">this</code> 値を与える。</li>
                    <li>Result(1) の文字数を算出する。</li>
                    <li>ToInteger(<var>start</var>) を呼出す。</li>
                    <li><var>end</var> が undefined ならば、 Result(2) を使用する; そうでなければ ToInteger(<var>end</var>) を使用する。</li>
                    <li>Result(3) が 負 ならば、 max(Result(2)+Result(3),0) を使用する; そうでなければ min(Result(3),Result(2)) を使用する。
                    </li>
                    <li>Result(4) が 負 ならば、 max(Result(2)+Result(4),0) を使用する; そうでなければ min(Result(4),Result(2)) を使用する。
                    </li>
                    <li>max(Result(6)-Result(5),0) を算出する。</li>
                    <li>Result(1) から、位置 Result(5) の文字で開始する Result(7) 個の連続する文字で構成される文字列を返す。</li>
                </ol>
                <p><code>slice</code> メソッドの length プロパティは 2 である。</p>

                <div class="note">
                    <p><b>NOTE</b> <code>slice</code> 関数は故意に汎用的である; <code class="keyword">this</code> 値が String
                        オブジェクトであることを要求されない。それゆえ、他の種類のオブジェクトにメソッドとして転用可能である。</p>
                </div>

            </div>
            <!-- END of 15.5.4.13 Body -->

        </div>
        <!-- END of 15.5.4.13 -->


        <div class="section level3">
            <h3 id="section-15.5.4.14">15.5.4.14 String.prototype.split (separator, limit)</h3>


            <div class="body level3">
                <p>このオブジェクトを文字列に変換した結果の部分文字列が蓄積されている Array オブジェクトを返す。部分文字列は、 <var>separator</var> の出現の左から右への検索で決定される;
                    これらの出現は返される配列内の部分文字列の一部にはならないが、文字列値の分割を提供する。 <var>separator</var> の値は任意の長さの文字列、または RegExp オブジェクト
                    (つまり [[Class]] プロパティが &quot;RegExp&quot; であるオブジェクト; <a
                            href="15-10_RegExp_Objects.html#section-15.10">セクション 15.10</a> 参照) でもよい。</p>

                <p><var>separator</var> の値は空文字列、空の正規表現、空文字列にマッチする正規表現でもよい。この場合、 <var>separator</var>
                    は入力文字列の先頭または末尾の空部分文字列にマッチせず、また前の <var>separator</var> マッチの末尾の空部分文字列にもマッチしない。 (例えば、
                    <var>separator</var> が空文字列ならば、文字列は不可分の文字に分割される; 結果配列の長さと文字列の長さは等しく、各部分文字列は 1 文字だけを含む。) <var>separator</var>
                    が正規表現ならば、バックトラッキングでその位置の空でない部分文字列マッチが発生するとしても、この文字列の与えられた位置の最初のマッチのみ考慮する。 (例えば、
                    &quot;ab&quot;.<code>split</code>(/a*?/) が [&quot;a&quot;,&quot;b&quot;] と評価される一方、
                    &quot;ab&quot;.<code>split</code>(/a*/) は [&quot;&quot;,&quot;b&quot;] と評価される。)</p>

                <p>このオブジェクトが空文字列ならば(または空文字列に変換されるならば)、結果は <var>separator</var>
                    が空文字列にマッチ可能かどうかに依存する。可能ならば、結果は要素をもたない配列である。不可能ならば、結果は空文字である要素を 1 個持つ配列となる。</p>

                <p><var>separator</var> が捕捉括弧を含む正規表現ならば、 <var>separator</var> が捕捉括弧の結果 (結果 undefined を含む)
                    にマッチするごとに、出力配列内に継ぎ足される。 (例えば、 &quot;A&lt;B&gt;bold&lt;/B&gt;and&lt;CODE&gt;coded&lt;/CODE&gt;&quot;.<code>split</code>(/&lt;(\/)?([^&lt;&gt;]+)&gt;/)
                    は配列 [&quot;A&quot;, undefined, &quot;B&quot;, &quot;bold&quot;, &quot;/&quot;, &quot;B&quot;, &quot;and&quot;,
                    undefined, &quot;CODE&quot;, &quot;coded&quot;, &quot;/&quot;, &quot;CODE&quot;, &quot;&quot;]
                    に評価される。)</p>

                <p><var>separator</var> が undefined ならば、結果の配列は <code class="keyword">this</code> 値 (文字列に変換された) である 1
                    個の文字列のみで構成される。 <var>limit</var> が undefined でないならば、出力配列は <var>limit</var> 個以下の要素になるように切り詰められる。</p>

                <p><code>split</code> が呼出されると、次のステップが取られる:</p>
                <ol>
                    <li><var>S</var> = ToString(this) とする。</li>
                    <li><var>A</var> を式 <code class="keyword">new</code> Array() によるものと同様の新しい配列とする。</li>
                    <li><var>limit</var> が undefined ならば、 lim = 2<sup>32</sup>-1 とする; そうでなければ lim =
                        ToUint32(<var>limit</var>) とする。
                    </li>
                    <li><var>s</var> を の文字数 <var>S</var> とする。</li>
                    <li><var>p</var> = 0 とする。</li>
                    <li><var>separator</var> が RegExp オブジェクト ([[Class]] が &quot;RegExp&quot;) ならば、 <var>R</var> = <var>separator</var>
                        とする; そうでなければ、 <var>R</var> = ToString(<var>separator</var>) とする。
                    </li>
                    <li>lim = 0 ならば、 <var>A</var> を返す。</li>
                    <li><var>separator</var> が undefined ならば、 ステップ 33 へ。</li>
                    <li><var>s</var> = 0 ならば、 ステップ 31 へ。</li>
                    <li><var>q</var> = <var>p</var> とする。</li>
                    <li><var>q</var> = <var>s</var> ならば、 ステップ 28 へ。</li>
                    <li>SplitMatch(<var>R</var>, <var>S</var>, <var>q</var>) を呼出し、 <var>z</var> をその MatchResult result
                        とする。
                    </li>
                    <li><var>z</var> が failure ならば、 ステップ 26 へ。</li>
                    <li><var>z</var> は State のはずである。 <var>e</var> を <var>z</var> の endIndex とし、 cap を <var>z</var>
                        の捕捉配列とする。
                    </li>
                    <li><var>e</var> = <var>p</var> ならば、 ステップ 26 へ。</li>
                    <li><var>T</var> を、 <var>S</var> の位置 <var>p</var> から <var>q</var> の前までの文字で構成される部分文字列に等しい文字列値とする。
                    </li>
                    <li><var>A</var> の [[Put]] メソッドを、引数 <var>A</var>.length, <var>T</var> で呼出す。</li>
                    <li><var>A</var>.length = lim ならば、 <var>A</var> を返す。</li>
                    <li><var>p</var> = <var>e</var> とする。</li>
                    <li><var>i</var> = 0 とする。</li>
                    <li><var>i</var> が cap 内の要素数と等しいならば、 ステップ 10 へ。</li>
                    <li><var>i</var> = <var>i</var>+1 とする。</li>
                    <li><var>A</var> の [[Put]] メソッドを、引数 <var>A</var>.length, cap[<var>i</var>] で呼出す。</li>
                    <li><var>A</var>.length = lim ならば、 <var>A</var> を返す。</li>
                    <li>ステップ 21 へ。</li>
                    <li><var>q</var> = <var>q</var>+1 とする。</li>
                    <li>ステップ 11 へ。</li>
                    <li><var>T</var> を、 <var>S</var> の位置 <var>p</var> から <var>s</var> の前までの文字で構成される部分文字列に等しい文字列値とする。
                    </li>
                    <li><var>A</var> の [[Put]] メソッドを、引数 <var>A</var>.length, <var>T</var> で呼出す。</li>
                    <li><var>A</var> を返す。</li>
                    <li>SplitMatch(<var>R</var>, <var>S</var>, <a href="Brief_History.html#section-0">0</a>) を呼出し、 <var>z</var>
                        をその MatchResult result とする。
                    </li>
                    <li><var>z</var> が failure でないならば、 <var>A</var> を返す。</li>
                    <li><var>A</var> の [[Put]] メソッドを、引数 &quot;0&quot; と <var>S</var> で呼出す。</li>
                    <li><var>A</var> を返す。</li>
                </ol>
                <p>内部補助関数 SplitMatch は 3 個のパラメータ、文字列 <var>S</var>, 整数 <var>q</var>, 文字列または正規表現 <var>R</var> をとり、次を実行して
                    MatchResult (セクション 15.10.2.1 参照) を返す:</p>
                <ol>
                    <li><var>R</var> が RegExp オブジェクト ([[Class]] が &quot;RegExp&quot;) ならば、 ステップ 8 へ。</li>
                    <li><var>R</var> は文字列でなければならない。 <var>r</var> を <var>R</var> の文字数とする。</li>
                    <li><var>s</var> を <var>S</var> の文字数とする。</li>
                    <li><var>q</var>+r &gt; <var>s</var> ならば MatchResult failure を返す。</li>
                    <li><var>S</var> の位置 <var>q</var>+r の文字が <var>R</var> の位置 <var>i</var> の文字と異なるような 0 から <var>r</var>
                        の前までの整数 <var>i</var> が存在するならば、 failure を返す。
                    </li>
                    <li>cap を captures (<a href="15-10_RegExp_Objects.html#section-15.10.2.1">セクション 15.10.2.1</a> 参照)
                        の空の配列とする。
                    </li>
                    <li>State (<var>q</var>+r, cap) を返す。 (<a href="15-10_RegExp_Objects.html#section-15.10.2.1">セクション
                        15.10.2.1</a> 参照)
                    </li>
                    <li><var>R</var> の [[Match]] メソッドを呼出し引数に <var>S</var> と <var>q</var> を与え、 MatchResult result を返す。
                    </li>
                </ol>
                <p><code>split</code> メソッドの length プロパティは 2 である。</p>

                <div class="note">
                    <p><b>NOTE</b> <code>split</code> 関数は故意に汎用的である; <code class="keyword">this</code> 値が String
                        オブジェクトであることを要求されない。それゆえ、他の種類のオブジェクトにメソッドとして転用可能である。</p>
                </div>

                <div class="note">
                    <p><b>NOTE</b> <code>split</code> メソッドは、 RegExp オブジェクトである separetor の <var>separator</var>.global
                        の値を無視する。</p>
                </div>

            </div>
            <!-- END of 15.5.4.14 Body -->

        </div>
        <!-- END of 15.5.4.14 -->


        <div class="section level3">
            <h3 id="section-15.5.4.15">15.5.4.15 String.prototype.substring (start, end)</h3>


            <div class="body level3">
                <p><code>substring</code> メソッドは 2 個の引数 <var>start</var> と <var>end</var> をとり、このオブジェクトの文字列への変換結果の、位置
                    <var>start</var> の文字から開始して位置 <var>end</var> の前の文字までを含む部分文字列を返す (または文字列の末尾までなら <var>end</var> は
                    undefined である)。 結果は文字列値となり、 String オブジェクトにはならない。</p>

                <p>引数が NaN または負の値のいずれかならば、 0 に置換される; 引数が文字列の長さより大きいならば、文字列の長さに置換される。</p>

                <p><var>start</var> が <var>end</var> より大きいならば、それらは交換される。</p>

                <p>次のステップが取られる:</p>
                <ol>
                    <li>ToString を呼出し、引数に <code class="keyword">this</code> 値を与える。</li>
                    <li>Result(1) の文字数を算出する。</li>
                    <li>ToInteger(<var>start</var>) を呼出す。</li>
                    <li><var>end</var> が undefined ならば、 Result(2) を用いる; そうでなければ ToInteger(<var>end</var>) を用いる。</li>
                    <li>min(max(Result(3), <a href="Brief_History.html#section-0">0</a>), Result(2)) を算出する。</li>
                    <li>min(max(Result(4), <a href="Brief_History.html#section-0">0</a>), Result(2)) を算出する。</li>
                    <li>min(Result(5), Result(6)) を算出する。</li>
                    <li>max(Result(5), Result(6)) を算出する。</li>
                    <li>長さが Result(8) と Result(7) の差であり、 Result(1) からの文字、すなわち昇順の添え字で Result(7) から Result(8)-1
                        までの文字を含む文字列を返す。
                    </li>
                </ol>
                <p><code>substring</code> メソッドの length プロパティは 2 である。</p>

                <div class="note">
                    <p><b>NOTE</b> <code>substring</code> 関数は故意に汎用的である; <code class="keyword">this</code> 値が String
                        オブジェクトであることを要求されない。それゆえ、他の種類のオブジェクトにメソッドとして転用可能である。</p>
                </div>

            </div>
            <!-- END of 15.5.4.15 Body -->

        </div>
        <!-- END of 15.5.4.15 -->


        <div class="section level3">
            <h3 id="section-15.5.4.16">15.5.4.16 String.prototype.toLowerCase ( )</h3>


            <div class="body level3">
                <p>このオブジェクトが文字列でないならば、文字列に変換される。文字列内の文字は、一つ一つ小文字に変換される。結果は文字列値となり、 String オブジェクトにはならない。</p>

                <p>文字は一つ一つ変換される。各変換の結果は、文字が Unicode 小文字 (Unicode lowercase equivalent)
                    を持つならばそれが使われ、持たないならばオリジナルの文字である。</p>

                <div class="note">
                    <p><b>NOTE</b> 結果は Unicode 文字データベース (これは UnicodeData.txt ファイルだけでなく、 Unicode 2.1.8 以降に含まれる
                        SpecialCasings.txt ファイルも明示的に含む) 内におけるケースマッピングに従い引き出されるべきである。</p>
                </div>

                <div class="note">
                    <p><b>NOTE</b> <code>toLowerCase</code> 関数は故意に汎用的である; <code class="keyword">this</code> 値が String
                        オブジェクトであることを要求されない。それゆえ、他の種類のオブジェクトにメソッドとして転用可能である。</p>
                </div>

            </div>
            <!-- END of 15.5.4.16 Body -->

        </div>
        <!-- END of 15.5.4.16 -->


        <div class="section level3">
            <h3 id="section-15.5.4.17">15.5.4.17 String.prototype.toLocaleLowerCase ( )</h3>


            <div class="body level3">
                <p>この関数は厳密に toLowerCase と同様に動作する。但し、結果はロケールから独立した結果ではなく、ホスト環境の現在のロケールに対して正しい結果をもたらすことが意図される。正規 Unicode
                    文字マッピングで言語の規則が干渉する (たとえばトルコ語のような) ごく一部の文字でのみ違いが存在する。</p>

                <div class="note">
                    <p><b>NOTE</b> <code>toLocaleLowerCase</code> 関数は故意に汎用的である; <code class="keyword">this</code> 値が
                        String オブジェクトであることを要求されない。それゆえ、他の種類のオブジェクトにメソッドとして転用可能である。</p>
                </div>

                <div class="note">
                    <p><b>NOTE</b> この関数の第一パラメータは、この標準の将来のバージョンで使用される可能性がある; 実装はこのパラメータを他の用途に使用しないことを推奨する。</p>
                </div>

            </div>
            <!-- END of 15.5.4.17 Body -->

        </div>
        <!-- END of 15.5.4.17 -->


        <div class="section level3">
            <h3 id="section-15.5.4.18">15.5.4.18 String.prototype.toUpperCase ( )</h3>


            <div class="body level3">
                <p>この関数は String.prototype.toLowerCase ときっちり同じように振舞う。但し、文字は Unicode 文字データベースで規定される大文字の同じ文字にマップされる。</p>

                <div class="note">
                    <p><b>NOTE</b> <code>toUpperCase</code> と toLowerCase はともにコンテキストに反応する振る舞いを持つため、関数は非対称的である。言い換えると、
                        <var>s</var>.<code>toUpperCase</code>().toLowerCase() は <var>s</var>.toLowerCase() と等しいとは限らない。
                    </p>
                </div>

                <div class="note">
                    <p><b>NOTE</b> <code>toUpperCase</code> 関数は故意に汎用的である; <code class="keyword">this</code> 値が String
                        オブジェクトであることを要求されない。それゆえ、他の種類のオブジェクトにメソッドとして転用可能である。</p>
                </div>

            </div>
            <!-- END of 15.5.4.18 Body -->

        </div>
        <!-- END of 15.5.4.18 -->


        <div class="section level3">
            <h3 id="section-15.5.4.19">15.5.4.19 String.prototype.toLocaleUpperCase ( )</h3>


            <div class="body level3">
                <p>この関数は厳密に toUpperCase と同様に動作する。但し、結果はロケールから独立した結果ではなく、ホスト環境の現在のロケールに対して正しい結果をもたらすことが意図される。正規 Unicode
                    文字マッピングで言語の規則が干渉する (たとえばトルコ語のような) ごく一部の文字でのみ違いが存在する。</p>

                <div class="note">
                    <p><b>NOTE</b> <code>toLocaleUpperCase</code> 関数は故意に汎用的である; <code class="keyword">this</code> 値が
                        String オブジェクトであることを要求されない。それゆえ、他の種類のオブジェクトにメソッドとして転用可能である。</p>
                </div>

                <div class="note">
                    <p><b>NOTE</b> この関数の第一パラメータは、この標準の将来のバージョンで使用される可能性がある; 実装はこのパラメータを他の用途に使用しないことを推奨する。</p>
                </div>

            </div>
            <!-- END of 15.5.4.19 Body -->

        </div>
        <!-- END of 15.5.4.19 -->

    </div>
    <!-- END of 15.5.4 -->


    <div class="section level2">
        <h2 id="section-15.5.5">15.5.5 String インスタンスのプロパティ (Properties of String Instances)</h2>


        <div class="body level2">
            <p>String インスタンスは、 String プロトタイプオブジェクトからプロパティを継承し、また [[Value]] プロパティと length プロパティを持つ。</p>

            <p>[[Value]] プロパティは、この String オブジェクトによってあらわされる文字列値である。</p>
        </div>
        <!-- END of 15.5.5 Body -->


        <div class="section level3">
            <h3 id="section-15.5.5.1">15.5.5.1 length</h3>


            <div class="body level3">
                <p>この String オブジェクトによってあらわされる String 値の文字数である。</p>

                <p>一旦 String が生成されたら、このプロパティは変更されない。属性 { DontEnum, DontDelete, ReadOnly } である。</p>
            </div>
            <!-- END of 15.5.5.1 Body -->

        </div>
        <!-- END of 15.5.5.1 -->

    </div>
    <!-- END of 15.5.5 -->

</div>
<!-- END of 15.5 -->

<h1>Page Contents</h1>
<ul id="toc">
    <li><a href="#section-15.5">15.5 String オブジェクト (String Objects)</a>
        <ul>
            <li><a href="#section-15.5.1">15.5.1 関数として呼出される String コンストラクタ (The String Constructor Called as a
                Function)</a>
                <ul>
                    <li><a href="#section-15.5.1.1">15.5.1.1 String ( [ value ] )</a></li>
                </ul>
            </li>
            <li><a href="#section-15.5.2">15.5.2 String コンストラクタ (The String Constructor)</a>
                <ul>
                    <li><a href="#section-15.5.2.1">15.5.2.1 new String ( [ value ] )</a></li>
                </ul>
            </li>
            <li><a href="#section-15.5.3">15.5.3 String コンストラクタ のプロパティ (Properties of the String Constructor)</a>
                <ul>
                    <li><a href="#section-15.5.3.1">15.5.3.1 String.prototype</a></li>
                    <li><a href="#section-15.5.3.2">15.5.3.2 String.fromCharCode ( [ char0 [ , char1 [ , ... ] ] ] )</a>
                    </li>
                </ul>
            </li>
            <li><a href="#section-15.5.4">15.5.4 String プロトタイプオブジェクトのプロパティ (Properties of the String Prototype
                Object)</a>
                <ul>
                    <li><a href="#section-15.5.4.1">15.5.4.1 String.prototype.constructor</a></li>
                    <li><a href="#section-15.5.4.2">15.5.4.2 String.prototype.toString ( )</a></li>
                    <li><a href="#section-15.5.4.3">15.5.4.3 String.prototype.valueOf ( )</a></li>
                    <li><a href="#section-15.5.4.4">15.5.4.4 String.prototype.charAt (pos)</a></li>
                    <li><a href="#section-15.5.4.5">15.5.4.5 String.prototype.charCodeAt (pos)</a></li>
                    <li><a href="#section-15.5.4.6">15.5.4.6 String.prototype.concat ( [ string1 [ , string2 [ , ... ] ]
                        ] )</a></li>
                    <li><a href="#section-15.5.4.7">15.5.4.7 String.prototype.indexOf (searchString, position)</a></li>
                    <li><a href="#section-15.5.4.8">15.5.4.8 String.prototype.lastIndexOf (searchString, position)</a>
                    </li>
                    <li><a href="#section-15.5.4.9">15.5.4.9 String.prototype.localeCompare (that)</a></li>
                    <li><a href="#section-15.5.4.10">15.5.4.10 String.prototype.match (regexp)</a></li>
                    <li><a href="#section-15.5.4.11">15.5.4.11 String.prototype.replace (searchValue, replaceValue)</a>
                    </li>
                    <li><a href="#section-15.5.4.12">15.5.4.12 String.prototype.search (regexp)</a></li>
                    <li><a href="#section-15.5.4.13">15.5.4.13 String.prototype.slice (start, end)</a></li>
                    <li><a href="#section-15.5.4.14">15.5.4.14 String.prototype.split (separator, limit)</a></li>
                    <li><a href="#section-15.5.4.15">15.5.4.15 String.prototype.substring (start, end)</a></li>
                    <li><a href="#section-15.5.4.16">15.5.4.16 String.prototype.toLowerCase ( )</a></li>
                    <li><a href="#section-15.5.4.17">15.5.4.17 String.prototype.toLocaleLowerCase ( )</a></li>
                    <li><a href="#section-15.5.4.18">15.5.4.18 String.prototype.toUpperCase ( )</a></li>
                    <li><a href="#section-15.5.4.19">15.5.4.19 String.prototype.toLocaleUpperCase ( )</a></li>
                </ul>
            </li>
            <li><a href="#section-15.5.5">15.5.5 String インスタンスのプロパティ (Properties of String Instances)</a>
                <ul>
                    <li><a href="#section-15.5.5.1">15.5.5.1 length</a></li>
                </ul>
            </li>
        </ul>
    </li>
</ul>

<address>

    Translate: <span>Sun Apr  7 08:52:56 2002</span>

<span>TAKI &lt;<a rel="bookmark" title="Translator"
                  href="mailto:TAKI%20%3Coz-07ams@mvh.biglobe.ne.jp%3E"
        >oz-07ams&#64;mvh.biglobe.ne.jp</a>&gt;</span>

</address>

</body>

</html>


<!--
     FILE ARCHIVED ON 20:41:36 Aug 2, 2014 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 16:14:59 Feb 6, 2015.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
